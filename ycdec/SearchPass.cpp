
#include <iostream>
#include <conio.h>
#include <vector>
#include <bit>
#include "SearchPass.h"

const unsigned char SearchPass::chrcode[] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x2D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2B,0x00,0x00,
	0x25,0x04,0x0C,0x14,0x1C,0x24,0x05,0x0D,0x15,0x1D,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x08,0x10,0x18,0x20,0x28,0x30,0x01,0x09,0x11,0x19,0x21,0x29,0x31,0x02,
	0x0A,0x12,0x1A,0x22,0x2A,0x32,0x03,0x0B,0x13,0x1B,0x23,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x35,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x2C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
int SearchPass::kat31F7;
int SearchPass::kat31F8;
int SearchPass::kat31F9;
int SearchPass::kat31FA;
int SearchPass::kat31FB;

// コンストラクタ
SearchPass::SearchPass(int kF7, int kF8, int kF9, int kFA, int kFB)
{

	kat31F7 = kF7;
	kat31F8 = kF8;
	kat31F9 = kF9;
	kat31FA = kFA;
	kat31FB = kFB;

}

bool SearchPass::checkPass(Word wd)
{
	bool result;
	std::vector<unsigned char> buffer;

	// 文字コード変換
	for (unsigned char idx = 0; idx < wd.length; ++idx) {
		buffer.push_back(chrcode[wd.str[idx]]);
	}

	result = false;

	unsigned char	a(0), c(0);
	unsigned char	mem2[2] = { 0, 0 };
	unsigned char	mem5[5] = { 0,0,0,1,0 };

	auto ror = [&c](unsigned char v)
	{
		unsigned char wc = c;

		c = v & 0x01;
		return (unsigned char)((v >> 1) | (wc << 7));
	};

	auto adc = [&c](unsigned char lhs, unsigned char rhs)
	{
		unsigned short v;

		v = (unsigned short)lhs + (unsigned short)rhs + (unsigned short)c;
		c = (v > 0xFF) ? 1 : 0;

		return (v & 0xFF);
	};

	for (unsigned char chr : buffer) {
		a = chr;
		// calc checkdigit1
		for (int bit = 7; bit >= 0; --bit) {
			c = (a >> bit) & 1;
			mem2[0] = ror(mem2[0]);
			mem2[1] = ror(mem2[1]);

			if (c) {
				mem2[0] ^= 0x84;
				mem2[1] ^= 0x08;
			}
		}
		// calc checkdigit2
		c = (mem2[0] >= 0xE5) ? 1 : 0;
		mem5[0] = adc(a, mem5[0]);
		mem5[1] = adc(mem5[1], mem2[1]);
		// calc checkdigit3
		mem5[2] ^= a;
		// calc checkdigit4
		{
			unsigned char v = ror(mem5[3]);
			mem5[3] = adc(v, a);
		}
		// calc checkdigit5
		mem5[4] += (unsigned char)(c + std::popcount(a));
	}

	result = ( true
//		&& (mem2[0] == kat31F4)
//		&& (mem2[0] == kat31F5)
		&& (mem5[0] == kat31F7)
		&& (mem5[1] == kat31F8)
		&& (mem5[2] == kat31F9)
		&& (mem5[3] == kat31FA)
		&& (mem5[4] == kat31FB)
		);
	if ((mem2[0] == 0x65) && (mem2[1] == 0x94)) {
		for (int idx = 0; idx < 14; ++idx) {
			fprintf(stderr, "0x%02X ", chrcode[wd.str[idx]]);
		}
		fprintf(stderr, "\n");

		fprintf(stderr, "chk %14s %02x %02x 0E %02x %02x %02x %02x %02x\n",
			wd.str, mem2[0], mem2[1], mem5[0], mem5[1], mem5[2], mem5[3], mem5[4]);
	}
	if (result) {
		return (true);
	}
	return (false);
}
